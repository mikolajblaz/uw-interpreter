-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParMbCore where
import AbsMbCore
import LexMbCore
import ErrM

}

%name pBody Body
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '->' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  '/' { PT _ (TS _ 10) }
  '/=' { PT _ (TS _ 11) }
  '::' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '[' { PT _ (TS _ 20) }
  '\\' { PT _ (TS _ 21) }
  ']' { PT _ (TS _ 22) }
  '_' { PT _ (TS _ 23) }
  'case' { PT _ (TS _ 24) }
  'data' { PT _ (TS _ 25) }
  'else' { PT _ (TS _ 26) }
  'end' { PT _ (TS _ 27) }
  'if' { PT _ (TS _ 28) }
  'in' { PT _ (TS _ 29) }
  'let' { PT _ (TS _ 30) }
  'of' { PT _ (TS _ 31) }
  'then' { PT _ (TS _ 32) }
  '{' { PT _ (TS _ 33) }
  '|' { PT _ (TS _ 34) }
  '||' { PT _ (TS _ 35) }
  '}' { PT _ (TS _ 36) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Var { PT _ (T_Var $$) }
L_Con { PT _ (T_Con $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }
Var    :: { Var} : L_Var { Var ($1)}
Con    :: { Con} : L_Con { Con ($1)}

Body :: { Body }
Body : ListTopDecl { AbsMbCore.Body (reverse $1) }
TopDecl :: { TopDecl }
TopDecl : DataDecl { AbsMbCore.DataDecl $1 }
        | Decl { AbsMbCore.Decl $1 }
ListTopDecl :: { [TopDecl] }
ListTopDecl : {- empty -} { [] }
            | ListTopDecl TopDecl ';' { flip (:) $1 $2 }
ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] }
         | Decl { (:[]) $1 }
         | Decl ';' ListDecl { (:) $1 $3 }
Decl :: { Decl }
Decl : Signature { AbsMbCore.Signature $1 }
     | Var '=' Exp { AbsMbCore.VarDecl $1 $3 }
Signature :: { Signature }
Signature : Var '::' Type { AbsMbCore.Sign $1 $3 }
ListSignature :: { [Signature] }
ListSignature : Signature { (:[]) $1 }
              | Signature ',' ListSignature { (:) $1 $3 }
DataDecl :: { DataDecl }
DataDecl : 'data' Con '=' ListConstr { AbsMbCore.Data $2 $4 }
Constr :: { Constr }
Constr : Con ListType1 { AbsMbCore.DataCon $1 (reverse $2) }
ListConstr :: { [Constr] }
ListConstr : Constr { (:[]) $1 }
           | Constr '|' ListConstr { (:) $1 $3 }
ListType1 :: { [Type] }
ListType1 : {- empty -} { [] } | ListType1 Type1 { flip (:) $1 $2 }
Type :: { Type }
Type : Type1 '->' Type { AbsMbCore.FunType $1 $3 } | Type1 { $1 }
Type1 :: { Type }
Type1 : Con { AbsMbCore.TyCon $1 }
      | '(' Type ',' ListType ')' { AbsMbCore.TupleType $2 $4 }
      | '[' Type ']' { AbsMbCore.ListType $2 }
      | '(' Type ')' { $2 }
ListType :: { [Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }
Exp6 :: { Exp }
Exp6 : '\\' ListSignature '.' Exp 'end' { AbsMbCore.Lambda $2 $4 }
     | 'let' '{' ListDecl '}' 'in' Exp 'end' { AbsMbCore.Let $3 $6 }
     | 'if' Exp 'then' Exp 'else' Exp 'end' { AbsMbCore.If $2 $4 $6 }
     | 'case' Exp 'of' '{' ListAlt '}' { AbsMbCore.Case $2 $5 }
     | Exp7 { $1 }
Exp7 :: { Exp }
Exp7 : Exp7 Exp8 { AbsMbCore.FApp $1 $2 } | Exp8 { $1 }
Exp8 :: { Exp }
Exp8 : Var { AbsMbCore.VarExp $1 }
     | Con { AbsMbCore.ConExp $1 }
     | Literal { AbsMbCore.LitExp $1 }
     | '(' Exp ',' ListExp ')' { AbsMbCore.TupleExp $2 $4 }
     | '[' ListExp ']' { AbsMbCore.ListExp $2 }
     | '(' Exp ')' { $2 }
Alt :: { Alt }
Alt : Pat '->' Exp { AbsMbCore.Alt $1 $3 }
Exp :: { Exp }
Exp : Exp1 { $1 }
Exp1 :: { Exp }
Exp1 : Exp2 { $1 } | Exp2 '||' Exp1 { AbsMbCore.OOr $1 $3 }
Exp2 :: { Exp }
Exp2 : Exp3 { $1 } | Exp3 '&&' Exp2 { AbsMbCore.OAnd $1 $3 }
Exp3 :: { Exp }
Exp3 : Exp4 { $1 } | Exp4 CompOp Exp4 { AbsMbCore.EOpE $1 $2 $3 }
Exp4 :: { Exp }
Exp4 : Exp5 { $1 }
     | Exp4 '+' Exp5 { AbsMbCore.OAdd $1 $3 }
     | Exp4 '-' Exp5 { AbsMbCore.OSub $1 $3 }
     | '-' Exp5 { AbsMbCore.ONeg $2 }
Exp5 :: { Exp }
Exp5 : Exp6 { $1 }
     | Exp5 '*' Exp6 { AbsMbCore.OMul $1 $3 }
     | Exp5 '/' Exp6 { AbsMbCore.ODiv $1 $3 }
ListExp :: { [Exp] }
ListExp : Exp { (:[]) $1 } | Exp ',' ListExp { (:) $1 $3 }
ListAlt :: { [Alt] }
ListAlt : {- empty -} { [] }
        | Alt { (:[]) $1 }
        | Alt ';' ListAlt { (:) $1 $3 }
ListVar :: { [Var] }
ListVar : Var { (:[]) $1 } | Var ListVar { (:) $1 $2 }
CompOp :: { CompOp }
CompOp : '==' { AbsMbCore.OEq }
       | '/=' { AbsMbCore.ONeq }
       | '<' { AbsMbCore.OLt }
       | '<=' { AbsMbCore.OLte }
       | '>' { AbsMbCore.OGt }
       | '>=' { AbsMbCore.OGte }
Pat :: { Pat }
Pat : Con ListPat1 { AbsMbCore.ConPat $1 (reverse $2) }
    | Pat1 { $1 }
Pat1 :: { Pat }
Pat1 : Var { AbsMbCore.VarPat $1 }
     | Literal { AbsMbCore.LitPat $1 }
     | '_' { AbsMbCore.WildCard }
     | '(' Pat ',' ListPat ')' { AbsMbCore.TuplePat $2 $4 }
     | '[' ListPat ']' { AbsMbCore.ListPat $2 }
     | '(' Pat ')' { $2 }
ListPat :: { [Pat] }
ListPat : Pat { (:[]) $1 } | Pat ',' ListPat { (:) $1 $3 }
ListPat1 :: { [Pat] }
ListPat1 : {- empty -} { [] } | ListPat1 Pat1 { flip (:) $1 $2 }
Literal :: { Literal }
Literal : Integer { AbsMbCore.IntLit $1 }
        | Double { AbsMbCore.DoubleLit $1 }
        | Char { AbsMbCore.CharLit $1 }
        | String { AbsMbCore.StringLit $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

