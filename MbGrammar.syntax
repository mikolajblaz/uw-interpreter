--- module	->	module modid [exports] where body
---        |	body

body	->	topdecl1 ; ... ; topdecln	(n>=0)
topdecl	→	data simpletype = constrs
        |	decl

decls	→	{ decl1 ; … ; decln }	    (n ≥ 0)
decl	→	var :: type	    (type signature)
        |	funlhs = exp [where decls]
        |		             (empty declaration)

type	→	btype [-> type]	    (function type)

btype	→	[btype] atype	    (type application)

atype	→	gtycon
        |	tyvar
        |	( type1 , … , typek )	    (tuple type, k ≥ 2)
        |	[ type ]	    (list type)
        |	( type )	    (parenthesized constructor)

gtycon	→	qtycon
        |	()	    (unit type)
        |	[]	    (list constructor)
        |	(->)	    (function constructor)
        |	(,{,})	    (tupling constructors)


simpletype	→	tycon tyvar1 … tyvark	    (k ≥ 0)
constrs	→	constr1 | … | constrn	    (n ≥ 1)
constr	→	con atype1 … atypek	    (arity con  =  k, k ≥ 0)


funlhs	→	var apat { apat }

exp	→	infixexp :: type	    (expression type signature)
        |	infixexp

infixexp	→	lexp op infixexp	    (infix operator application)
        |	- infixexp	    (prefix negation)
        |	lexp

lexp	→	\ apat1 … apatn -> exp	    (lambda abstraction, n ≥ 1)
        |	let decls in exp	    (let expression)
        |	if exp [;] then exp [;] else exp	    (conditional)
        |	case exp of { alts }	    (case expression)
        |	fexp

fexp	→	[fexp] aexp	    (function application)

aexp	→	var	    (variable)
        |	gcon	    (general constructor)
        |	literal
        |	( exp )	    (parenthesized expression)
        |	( exp1 , … , expk )	    (tuple, k ≥ 2)
        |	[ exp1 , … , expk ]	    (list, k ≥ 1)
        |	[ exp1 [, exp2] .. [exp3] ]	    (arithmetic sequence)

alts  	→	alt1 ; … ; altn	    (n ≥ 1)
alt	    →	pat -> exp [where decls]
        |		    (empty alternative)

pat	→	apat
        |	- (integer | float)	    (negative literal)
        |	gcon apat1 … apatk	    (arity gcon  =  k, k ≥ 1)

apat	→	var
        |	gcon	    (arity gcon  =  0)
        |	literal
        |	_	    (wildcard)
        |	( pat )	    (parenthesized pattern)
        |	( pat1 , … , patk )	    (tuple pattern, k ≥ 2)
        |	[ pat1 , … , patk ]	    (list pattern, k ≥ 1)

gcon	→	()
        |	[]
        |	(,{,})
        |	con

var	→	varid | ( varsym )	    (variable)
con	→	conid | ( consym )	    (constructor)
op	→	varop | conop	    (operator)
