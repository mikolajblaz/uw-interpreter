Body.        Body ::= [TopDecl] ;

Data.        TopDecl ::= "data" SimpleType = [Constr]
Decl.        TopDecl ::= Decl

(:[]).       [TopDecl] ::= TopDecl;
(:).         [TopDecl] ::= TopDecl ";" [TopDecl];
(:[]).       [Decl] ::= Decl;
(:).         [Decl] ::= Decl ";" [Decl];

EmptyDecl.   Decl ::= "";                 --- empty declaration
Signature.   Decl ::= Var "::" Type       --- signature declaration
FunDecl.     Decl ::= FunLhs "=" Exp      --- function declaration
PatDecl.     Decl ::= Pat "=" Exp         --- pattern declaration

BType.       Type ::= BType
FunBType.    Type ::= BType "->" Type	    --- function type

AType.       BType ::= AType
AppAType.    BType ::= BType AType	    --- type application

GTyCon.      AType ::= GTyCon
TyVar.       AType ::= TyVar
TupleType.   AType ::= "(" Type "," [ManyType] ")"	    --- tuple type
ListType.    AType ::= "[" Type "]"	                    --- list type
ParenType.   AType ::= "(" Type ")"                     --- parenthesized constructor

QTyCon.      GTyCon ::= QTyCon
UnitCon.     GTyCon ::= "()"                            --- unit constructor
ListCon.     GTyCon ::= "[]"                            --- list constructor
FunCon.      GTyCon ::= "(->)"                          --- function constructor
TupleCon.    GTyCon ::= "(" Comma [ManyComma] ")"       --- tuple constructor

(:[]).       [ManyType] ::= Type;
(:).         [ManyType] ::= Type "," [ManyType];

ZeroTyCon.   SimpleType	::=	TyCon                       --- arity = 0
ManyTyCon.   SimpleType	::=	TyCon [TyVar]               --- arity > 0
ZeroCon.     Constr ::= Con                             --- arity = 0
ManyCon.     Constr ::= Con [AType]                     --- arity > 0

(:[]).       [TyVar] ::= TyVar
(:[]).       [TyVar] ::= TyVar [TyVar]
(:[]).       [AType] ::= AType
(:[]).       [AType] ::= AType [AType]

(:[]).       [Constr] ::= Constr
(:[]).       [Constr] ::= Constr "|" [Constr]

VarFunLhs.   FunLhs ::= Var APat [APat]

QOpExp.      Exp ::= LExp QOp Exp     --- infix operator application
NegExp.      Exp ::= "-" Exp          --- prefix negation
LExp.        Exp ::= LExp


Lambda.      LExp ::= "\\" [APat] "->" Exp	              --- lambda abstraction
Let.         LExp ::= "let" [Decl] "in" Exp	            --- let expression
If.          LExp ::= "if" Exp "then" Exp "else" Exp	  --- conditional
Case.        LExp ::= "case" Exp "of" "{" [Alt] "}"	    --- case expression
FExp.        LExp ::= FExp

FApp.        FExp	::= FExp AExp                         --- function application
AExp.        FExp	::= AExp

Var.         AExp ::= Var	                            --- variable
GCon.        AExp ::= GCon	                            --- general constructor
Literal      AExp ::= Literal
ParExp.      AExp ::= "(" Exp ")"	                      --- parenthesized expression
TupleExp.    AExp ::= "(" Exp "," [ManyExp] ")"	        --- tuple
ListExp.     AExp ::= "[" [ManyExp] "]"                 --- list

(:[]).       [ManyExp] ::= Exp
(:).         [ManyExp] ::= Exp "," [ManyExp]

(:[]).       [Alt] ::= Alt
(:).         [Alt] ::= Alt ";" [Alt]


Alt.         Alt ::= Pat "->" Exp
EmptyAlt.    Alt ::= ""                                 --- empty alternative


---- Patterns
APat.        Pat ::= APat
NegInteger.  Pat ::= "-" Integer
NegFloat.    Pat ::= "-" Float
GConPat.     Pat ::= GCon [APat]

(:[]).       [APat] ::= APat
(:).         [APat] ::= APat [APat]

Var.         APat ::= Var
GCon.        APat ::= GCon                              --- arity gcon = 0
Literal.     APat ::= Literal
WildCard.    APat ::= "_"
ParPat.      APat ::= "(" Pat ")"
TuplePat.    APat ::= "(" Pat "," [ManyPat] ")"	        --- tuple
ListPat.     APat ::= "[" [ManyPat] "]"                 --- list

(:[]).       [ManyPat] ::= Pat
(:).         [ManyPat] ::= Pat "," [ManyPat]

Con.         GCon ::= Con
Unit.        GCon ::= "()"
ListCon.     GCon ::= "[]"
TupleCon.    GCon ::= "(" Comma [ManyCommas] ")"

(:[]).       [ManyCommas] ::= Comma
(:).         [ManyCommas] ::= Comma [ManyCommas]
Comma.       Comma ::= ","





------------ Lexical Syntax
Var  ::=   lower { lower | upper | digit }
Con  ::=   large { lower | upper | digit }

Lower      ::=   a | b | c | ... | z
Upper      ::=   A | B | C | ... | Z
Digit      ::=   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
      (but reserved words (not allowed as variable names) include:
      case   class   data   default   deriving   do   else
      if   import   in   infix   infixl   infixr   instance
      let   module   newtype   of   then   type   where   )

Symbol    ::=   ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @  | \ | ^ | | | - | ~

Op ::= + | - | * | /

Literal    ::=   boollit   |   intlit   |   charlit   |   stringlit

boollit    ::=   True  |  False

intlit       ::=   Digit { Digit }

charlit           ::=   ' nonapost '
nonapost     ::=   (any character except apostrophe)

stringlit         ::=   " { nonqchar } "
nonqchar     ::=   (any character except quote mark)
(characters include "escaped" characters: \\, \', \", \t, \n )
