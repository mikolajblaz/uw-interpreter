Body.        Body ::= [TopDecl] ;

Data.        TopDecl ::= "data" SimpleType "=" [Constr] ;
Decl.        TopDecl ::= Decl ;

separator TopDecl ";" ;
separator Decl ";" ;
separator nonempty Constr "|" ;

EmptyDecl.   Decl ::= "" ;                 --- empty declaration
Signature.   Decl ::= Var "::" Type ;      --- signature declaration
FunDecl.     Decl ::= FunLhs "=" Exp ;     --- function declaration
PatDecl.     Decl ::= Pat "=" Exp ;        --- pattern declaration

ZeroArgFun.  FunLhs ::= Var ;
ManyArgFun.  FunLhs ::= Var [APat] ;

---- Types ----

BType.       Type ::= BType ;
FunBType.    Type ::= BType "->" Type ;    --- function type

AType.       BType ::= AType ;
AppAType.    BType ::= BType AType ;       --- type application

GTyCon.      AType ::= GTyCon ;
TyVar.       AType ::= TyVar ;
TupleType.   AType ::= "(" Type "," [Type] ")" ;        --- tuple type
ListType.    AType ::= "[" Type "]"	;                   --- list type
ParenType.   AType ::= "(" Type ")" ;                   --- parenthesized constructor

separator nonempty Type "," ;

QTyCon.      GTyCon ::= QTyCon ;
UnitCon.     GTyCon ::= "()" ;                          --- unit constructor
ListCon.     GTyCon ::= "[]" ;                          --- list constructor
FunCon.      GTyCon ::= "(->)" ;                        --- function constructor
TupleCon.    GTyCon ::= "(" [Comma] ")" ;               --- tuple constructor

TyCon.       SimpleType	::=	TyCon [TyVar] ;
Con.         Constr ::= Con [AType] ;
separator TyVar "" ;
separator AType "" ;


---- Expressions ----

QOpExp.      Exp ::= LExp QOp Exp ;     --- infix operator application
NegExp.      Exp ::= "-" Exp ;          --- prefix negation
LExp.        Exp ::= LExp ;


Lambda.      LExp ::= "\\" [APat] "->" Exp ;            --- lambda abstraction
Let.         LExp ::= "let" [Decl] "in" Exp	;           --- let expression
If.          LExp ::= "if" Exp "then" Exp "else" Exp ;  --- conditional
Case.        LExp ::= "case" Exp "of" "{" [Alt] "}" ;   --- case expression
FExp.        LExp ::= FExp ;

FApp.        FExp	::= FExp AExp ;                       --- function application
AExp.        FExp	::= AExp ;

Var.         AExp ::= Var	;                             --- variable
GCon.        AExp ::= GCon ;                            --- general constructor
Literal.     AExp ::= Literal ;
ParExp.      AExp ::= "(" Exp ")" ;                     --- parenthesized expression
TupleExp.    AExp ::= "(" Exp "," [Exp] ")" ;           --- tuple
ListExp.     AExp ::= "[" [Exp] "]" ;                   --- list

Alt.         Alt ::= Pat "->" Exp ;
EmptyAlt.    Alt ::= "" ;                               --- empty alternative

separator nonempty Exp "," ;
separator Alt ";" ;

---- Patterns ----

separator nonempty APat "" ;

APat.        Pat ::= APat ;
NegInteger.  Pat ::= "-" Integer ;
NegFloat.    Pat ::= "-" Float ;
GConPat.     Pat ::= GCon [APat] ;                      --- arity gcon > 0

Var.         APat ::= Var ;
GCon.        APat ::= GCon ;                            --- arity gcon = 0
Literal.     APat ::= Literal ;
WildCard.    APat ::= "_" ;
ParPat.      APat ::= "(" Pat ")" ;
TuplePat.    APat ::= "(" Pat "," [Pat] ")"	;           --- tuple
ListPat.     APat ::= "[" [Pat] "]" ;                   --- list

separator nonempty Pat "," ;

Con.         GCon ::= Con ;
Unit.        GCon ::= "()" ;
ListCon.     GCon ::= "[]" ;
TupleCon.    GCon ::= "(" [Comma] ")" ;

Comma.       Comma ::= "," ;
separator nonempty Comma "" ;


---- Lexical syntax ----
