Body.        Body ::= [TopDecl] ;

Data.        TopDecl ::= "data" TyConstr "=" [Constr] ;
Decl.        TopDecl ::= Decl ;

DataTyCon.   TyConstr	::=	TyCon [TyVar] ;
DataCon.     Constr ::= Con [AType] ;

separator TopDecl ";" ;
separator Decl ";" ;
separator nonempty Constr "|" ;
separator TyVar "" ;
separator AType "" ;

EmptyDecl.   Decl ::= "" ;                              --- empty declaration
Signature.   Decl ::= Var "::" Type ;                   --- signature declaration
FunDecl.     Decl ::= FunLhs "=" Exp ;                  --- function declaration
PatDecl.     Decl ::= Pat "=" Exp ;                     --- pattern declaration

ZeroArgFun.  FunLhs ::= Var ;
ManyArgFun.  FunLhs ::= Var [APat] ;

---- Types ----

BType.       Type ::= BType ;
FunBType.    Type ::= BType "->" Type ;                 --- function type

AType.       BType ::= AType ;
AppAType.    BType ::= BType AType ;                    --- type application

GTyCon.      AType ::= GTyCon ;
TyVar.       AType ::= TyVar ;
TupleType.   AType ::= "(" Type "," [Type] ")" ;        --- tuple type
ListType.    AType ::= "[" Type "]"	;                   --- list type
ParenType.   AType ::= "(" Type ")" ;                   --- parenthesized constructor

separator nonempty Type "," ;

SimpleTyCon. GTyCon ::= TyCon ;
UnitTyCon.   GTyCon ::= "()" ;                          --- unit constructor
ListTyCon.   GTyCon ::= "[]" ;                          --- list constructor
FunTyCon.    GTyCon ::= "(->)" ;                        --- function constructor
TupleTyCon.  GTyCon ::= "(" [Comma] ")" ;               --- tuple constructor


---- Expressions ----

OpExp.       Exp ::= LExp Op Exp ;                      --- operator application
NegExp.      Exp ::= "-" Exp ;                          --- prefix negation
LExp.        Exp ::= LExp ;


Lambda.      LExp ::= "\\" [APat] "->" Exp ;            --- lambda abstraction
Let.         LExp ::= "let" [Decl] "in" Exp	;           --- let expression
If.          LExp ::= "if" Exp "then" Exp "else" Exp ;  --- conditional
Case.        LExp ::= "case" Exp "of" "{" [Alt] "}" ;   --- case expression
FExp.        LExp ::= FExp ;

FApp.        FExp	::= FExp AExp ;                       --- function application
AExp.        FExp	::= AExp ;

VarExp.      AExp ::= Var	;                             --- variable
GConExp.     AExp ::= GCon ;                            --- general constructor
LitExp.      AExp ::= Literal ;
ParExp.      AExp ::= "(" Exp ")" ;                     --- parenthesized expression
TupleExp.    AExp ::= "(" Exp "," [Exp] ")" ;           --- tuple
ListExp.     AExp ::= "[" [Exp] "]" ;                   --- list

Alt.         Alt ::= Pat "->" Exp ;
EmptyAlt.    Alt ::= "" ;                               --- empty alternative

separator nonempty Exp "," ;
separator Alt ";" ;

---- TODO!
token Op ('+' | '-' | '*' | '/') ;

---- Patterns ----

separator nonempty APat "" ;

APat.        Pat ::= APat ;
NegIntPat.   Pat ::= "-" Integer ;
NegDoublePat.Pat ::= "-" Double ;
ManyGConPat. Pat ::= GCon [APat] ;                      --- arity gcon > 0

VarPat.      APat ::= Var ;
ZeroGConPat. APat ::= GCon ;                            --- arity gcon = 0
LitPat.      APat ::= Literal ;
WildCard.    APat ::= "_" ;
ParPat.      APat ::= "(" Pat ")" ;                     --- parenthesized pattern
TuplePat.    APat ::= "(" Pat "," [Pat] ")"	;           --- tuple
ListPat.     APat ::= "[" [Pat] "]" ;                   --- list

separator nonempty Pat "," ;

SimpleCon.   GCon ::= Con ;
UnitCon.     GCon ::= "()" ;
ListCon.     GCon ::= "[]" ;
TupleCon.    GCon ::= "(" [Comma] ")" ;

Comma.       Comma ::= "," ;
separator nonempty Comma "" ;


---- Lexical syntax ----
token Var (lower ( letter | digit )* ) ;
token Con (upper ( letter | digit )* ) ;

VarTyCon.    TyCon ::= Var ;
VarTyVar.    TyVar ::= Var ;

---- reserved words:  case  data  else  if  in  let  of  then

BoolLit.     Literal ::= BoolLit ;
IntLit.      Literal ::= Integer ;
CharLit.     Literal ::= Char ;
StringLit.   Literal ::= String ;

True.        BoolLit ::= "True" ;
False.       BoolLit ::= "False" ;

---- Comments ----
comment "--" ;
